<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <title>Registro de Actividad - PCT</title>
  
  <!-- SEO Meta Tags -->
  <meta name="description" content="Registro y seguimiento de actividades operacionales del sistema PCT.">
  <meta name="author" content="PCT">
  <link rel="canonical" href="https://pc-t.mx/actividad.html">
  
  <!-- Open Graph / Facebook -->
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://pc-t.mx/actividad.html">
  <meta property="og:title" content="Registro de Actividad - PCT">
  <meta property="og:description" content="Registro y seguimiento de actividades operacionales del sistema PCT.">
  <meta property="og:site_name" content="PCT">
  <script>
    const CSS_VERSION = Date.now();
    document.write('<link rel="stylesheet" href="styles.css?v=' + CSS_VERSION + '">');
    console.log('[actividad] CSS cargado con versi√≥n:', CSS_VERSION);
  </script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <link rel="icon" href="data:,">
  <meta name="color-scheme" content="light">
  <meta name="theme-color" content="#ffffff">
  <style>
    [data-page="actividad"] input#q { min-width: 240px; padding: 0.5rem 0.6rem; border: 1px solid #e5e7eb; border-radius: 8px; }
  </style>
</head>
<body data-page="actividad">
  <header>
    <div class="logo"><img src="img/logopctch.png" alt="Logo" /></div>
    <button class="menu-toggle" aria-label="Abrir men√∫" aria-controls="primary-nav" aria-expanded="false">‚ò∞</button>
    <nav id="primary-nav">
      <ul>
        <li><a href="index.html">Dashboard</a></li>
        <li class="nav-dropdown"><details><summary>Pruebas</summary><ul>
          <li><a href="pruebas.html">Pruebas</a></li>
          <li><a href="stockpruebas.html">Stock de pruebas</a></li>
          <li><a href="listapruebas.html">Lista de pruebas</a></li>
        </ul></details></li>
        <li><a href="tareas.html">Tareas</a></li>
        <li class="nav-dropdown"><details><summary>Inspecci√≥n</summary><ul>
          <li><a href="inspeccion.html">Inspecci√≥n primaria</a></li>
          <li><a href="reginspecciones.html">Registro de inspecciones</a></li>
        </ul></details></li>
        <li><a href="ingral.html">Inventario</a></li>
        <li class="nav-dropdown"><details open><summary>Actividad</summary><ul>
          <li><a class="active" href="actividad.html">Registro de actividad</a></li>
          <li><a href="regactividad.html">Historial de registros</a></li>
        </ul></details></li>
        <li><a href="reportes.html">Reportes</a></li>
      </ul>
    </nav>
    <div class="user-box">
      <span id="user-email"></span>
      <a id="login-link" href="login.html">Login</a>
      <button id="logout-btn" type="button" style="display:none">Salir</button>
    </div>
  </header>
  <main class="wide">
    <h1>Registro de Actividad</h1>

    <section id="activity-kpis" class="dashboard" style="margin: 12px 0 8px; display:none;">
      <div class="cards" id="activity-cards"></div>
    </section>

    <section id="summary" class="dashboard" style="margin-bottom: 10px; display:none;">
      <div class="cards" id="summary-cards"></div>
    </section>

    <div class="toolbar" role="region" aria-label="Herramientas de tabla">
      <div class="group">
        <input id="q" type="text" placeholder="Buscar..." aria-label="Buscar" />
        <button id="clearQ" class="btn-primary" type="button">Limpiar</button>
        <button id="newRowBtn" class="btn-primary" type="button">Nuevo registro</button>
        <button id="saveRowBtn" class="btn-primary" type="button" style="display:none;">Guardar</button>
        <button id="cancelRowBtn" type="button" style="display:none;">Cancelar</button>
      </div>
      <div class="toolbar-count" id="count">0 registros</div>
    </div>

    <div id="inventory-wrapper" class="table-responsive" aria-live="polite">
      <div class="scrollbar-x"><div class="scrollbar-content"></div></div>
      <div class="table-scroll">
        <table class="inventory" id="actTable" aria-describedby="count">
          <thead id="thead"></thead>
          <tbody id="tbody"></tbody>
        </table>
      </div>
    </div>

    <section id="activity-log" aria-label="Actividades registradas" style="margin-top:18px;">
      <h2 style="font-size:1rem; margin-bottom:8px;">Actividades registradas</h2>
      <ul id="activity-log-list" style="list-style:none; padding:0; margin:0; font-size:0.9rem; color:#334155;"></ul>
    </section>
  </main>
  <footer>
    <a href="https://unknownshoppers.com" target="_blank" rel="noopener noreferrer">Powered by <img src="img/logotus.jpg" alt="Unknown Shoppers" style="height:18px; vertical-align:middle"></a>
  </footer>

  <!-- Desregistrar service workers para evitar cach√© persistente en desarrollo -->
  <script>
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.getRegistrations().then(function(registrations) {
        for(let registration of registrations) {
          registration.unregister();
        }
      });
    }
  </script>
  <script src="https://www.gstatic.com/firebasejs/9.6.11/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.6.11/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.6.11/firebase-firestore-compat.js"></script>
  <script src="firebase-config.js"></script>
  <script src="firebase-init.js"></script>
  <script>
    // Cache-busting para script.js en desarrollo
    const SCRIPT_VERSION = Date.now();
    document.write('<script src="script.js?v=' + SCRIPT_VERSION + '"><\/script>');
  </script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script>
  (function(){
    const SRC_BASE = 'docs/REGISTRO DE ACTIVIDAD PCT 2025.csv';
    const SRC = SRC_BASE + '?t=' + Date.now();
    const INVENT_SRC = 'docs/INVENTARIO GENERAL PCT 2025 UNIFICADO.csv';
    const thead = document.getElementById('thead');
    const tbody = document.getElementById('tbody');
    const summary = document.getElementById('summary');
    const summaryCards = document.getElementById('summary-cards');
    const q = document.getElementById('q');
    const clearQ = document.getElementById('clearQ');
    const newRowBtn = document.getElementById('newRowBtn');
    const saveRowBtn = document.getElementById('saveRowBtn');
    const cancelRowBtn = document.getElementById('cancelRowBtn');
    const count = document.getElementById('count');
    const table = document.getElementById('actTable');
    const activityKpis = document.getElementById('activity-kpis');
    const activityCards = document.getElementById('activity-cards');

    let rows = [];
    let headers = [];
    let view = [];
    let sortCol = -1;
    let sortDir = 'asc';
    // Proyecci√≥n de columnas visibles en orden (√≠ndices calculados post parse)
    let visibleCols = null; // { order: number[], labels: string[] }
    let propiedadIdx = -1; // √≠ndice de la columna PROPIEDAD
    let diasServicioVisibleIdx = -1; // √≠ndice visible (no contando la columna de selecci√≥n)
    let equipoVisibleIdx = -1; // √≠ndice visible para EQUIPO/ACTIVO
    let descripcionVisibleIdx = -1; // √≠ndice visible para DESCRIPCION
    let serialVisibleIdx = -1; // √≠ndice visible para SERIAL
    let invDescByEquipo = new Map(); // mapa EQUIPO -> DESCRIPCION desde inventario
    let invSerialByEquipo = new Map(); // mapa EQUIPO -> SERIAL desde inventario
    let inventoryOptions = []; // opciones de inventario para internos
    let inventorySet = new Set(); // para verificaci√≥n r√°pida de pertenencia
    let externalOptionsByProvider = new Map(); // proveedor -> Set de claves sugeridas

    // Sincronizaci√≥n con Firestore
    const COLLECTION_NAME = 'activityRecords';
    let firebaseReady = false;
    
    // Esperar a que Firebase est√© disponible
    function waitForFirebase() {
      return new Promise((resolve) => {
        const check = () => {
          if (window.db && window.auth) {
            firebaseReady = true;
            resolve(true);
          } else {
            setTimeout(check, 100);
          }
        };
        check();
      });
    }
    
    // Guardar registro en Firestore
    async function saveToFirestore(row) {
      if (!firebaseReady || !window.db) {
        console.warn('[actividad] Firebase no disponible, solo se guard√≥ en localStorage');
        return null;
      }
      
      try {
        const rowData = Array.isArray(row) ? row : Object.values(row);
        const docRef = await window.db.collection(COLLECTION_NAME).add({
          row: rowData,
          timestamp: firebase.firestore.FieldValue.serverTimestamp(),
          createdAt: new Date().toISOString(),
          createdBy: window.auth.currentUser ? window.auth.currentUser.email : 'unknown'
        });
        console.log('[actividad] Registro guardado en Firestore:', docRef.id);
        return docRef.id;
      } catch (e) {
        console.error('[actividad] Error al guardar en Firestore:', e);
        return null;
      }
    }
    
    // Eliminar registro de Firestore
    async function deleteFromFirestore(firestoreId) {
      if (!firebaseReady || !window.db || !firestoreId) return;
      
      try {
        await window.db.collection(COLLECTION_NAME).doc(firestoreId).delete();
        console.log('[actividad] Registro eliminado de Firestore:', firestoreId);
      } catch (e) {
        console.error('[actividad] Error al eliminar de Firestore:', e);
      }
    }

    function fmt(n){ return n.toLocaleString('es-MX'); }

    function ensureDatalist(id, options){
      let dl = document.getElementById(id);
      if (!dl){ dl = document.createElement('datalist'); dl.id = id; document.body.appendChild(dl); }
      dl.innerHTML = '';
      (options||[]).forEach(opt=>{ const o=document.createElement('option'); o.value=opt; dl.appendChild(o); });
      return dl;
    }

    function endOfMonth(dt){
      const d = new Date(dt.getFullYear(), dt.getMonth()+1, 0);
      d.setHours(0,0,0,0);
      return d;
    }
    // Corte administrativo: d√≠a 25 de cada mes
    function cutoff25(dt){
      const d = new Date(dt.getFullYear(), dt.getMonth(), 25);
      d.setHours(0,0,0,0);
      if (dt > d){
        // pasar al 25 del siguiente mes
        return new Date(dt.getFullYear(), dt.getMonth()+1, 25);
      }
      return d;
    }
    // Continuaci√≥n: d√≠a 27 de ese mismo mes (2 d√≠as de gracia)
    function continuation27From(dateOn25){
      const d = new Date(dateOn25.getFullYear(), dateOn25.getMonth(), 27);
      d.setHours(0,0,0,0);
      return d;
    }
    function addDays(dt, n){ const d=new Date(dt); d.setDate(d.getDate()+n); d.setHours(0,0,0,0); return d; }
    function minDate(a,b){ return a<=b ? a : b; }
    function daysInclusive(a,b){ return Math.max(0, Math.ceil((b - a)/(1000*60*60*24)) + 1); }

    function renderHead(){
      const tr = document.createElement('tr');
      // Columna virtual inicial (no ordenable)
      const thSel = document.createElement('th');
      thSel.textContent = 'SELECCI√ìN';
      tr.appendChild(thSel);
      const labels = visibleCols ? visibleCols.labels : headers;
      labels.forEach((h, vIdx)=>{
        const th = document.createElement('th');
        th.textContent = h;
        th.setAttribute('role','button');
        th.tabIndex = 0;
        th.dataset.index = String(vIdx);
        if (vIdx === sortCol) th.dataset.sort = sortDir;
        th.addEventListener('click', ()=>toggleSort(vIdx));
        th.addEventListener('keydown', (ev)=>{ if (ev.key==='Enter' || ev.key===' ') { ev.preventDefault(); toggleSort(vIdx); } });
        tr.appendChild(th);
      });
      thead.innerHTML = '';
      thead.appendChild(tr);
    }

    function computeVisibleIndices(){
      if (!visibleCols){ diasServicioVisibleIdx = -1; equipoVisibleIdx = -1; return; }
      const labels = visibleCols.labels.map(h=>normalizeHeader(h).toUpperCase());
      diasServicioVisibleIdx = labels.indexOf('DIAS EN SERVICIO');
      // Variantes para EQUIPO / ACTIVO
      const variants = ['EQUIPO / ACTIVO','EQUIPO/ACTIVO','EQUIPO ACTIVO','EQUIPO'];
      equipoVisibleIdx = labels.findIndex(l => variants.includes(l));
      descripcionVisibleIdx = labels.indexOf('DESCRIPCION') >= 0 ? labels.indexOf('DESCRIPCION') : labels.indexOf('DESCRIPCI√ìN');
      // Buscar SERIAL (o '#' para compatibilidad)
      serialVisibleIdx = labels.indexOf('SERIAL');
      if (serialVisibleIdx < 0) serialVisibleIdx = labels.indexOf('#');
    }

    function rebuildEquipoCellForRow(tr){
      if (equipoVisibleIdx < 0) return;
      const cells = tr.children;
      // primera columna es selecci√≥n, as√≠ que sumamos 1
      const td = cells[1 + equipoVisibleIdx];
      if (!td) return;
      const firstCell = cells[0];
      const selEl = firstCell.querySelector('select');
      const tipo = selEl ? selEl.value : (firstCell.textContent||'EQUIPOS INTERNOS');
      const oldVal = (td.querySelector('input')?.value) || td.textContent || '';
      td.innerHTML = '';
      const input = document.createElement('input');
      input.type = 'text';
      input.value = String(oldVal||'').trim();
      if (tipo === 'EQUIPOS INTERNOS'){
        ensureDatalist('dl-inventory-equipos', inventoryOptions||[]);
        input.setAttribute('list', 'dl-inventory-equipos');
        input.placeholder = 'Equipo/Activo (inventario)';
      } else {
        input.placeholder = 'Clave del proveedor';
        // detectar proveedor seg√∫n PROPIEDAD del dataset de la fila (si existe)
        let prov = '';
        try {
          // Buscar valor PROPIEDAD de esta fila en el array 'view'
          const rowIndex = Array.from(tbody.children).indexOf(tr);
          const dataRow = view[rowIndex] || [];
          prov = propiedadIdx>=0 ? String(dataRow[propiedadIdx]||'').trim().toUpperCase() : '';
        } catch {}
        const dlid = 'dl-prov-' + (prov||'GEN');
        const opts = externalOptionsByProvider.get(prov) ? Array.from(externalOptionsByProvider.get(prov).values()) : [];
        ensureDatalist(dlid, opts);
        input.setAttribute('list', dlid);
      }
      td.appendChild(input);
      try { input.focus(); input.select(); } catch {}
    }

    function updateActivityKpis(){
      // Si no hay filas, ocultar
      if (!tbody.children.length){ activityKpis.style.display='none'; activityCards.innerHTML=''; return; }
      let total = 0, internos = 0, externos = 0;
      const rowsEl = tbody.querySelectorAll('tr');
      rowsEl.forEach(tr=>{
        const cells = tr.children;
        if (!cells || cells.length === 0) return;
        const sel = cells[0].querySelector('select');
        let tipo = 'EQUIPOS INTERNOS';
        if (sel) tipo = sel.value;
        else tipo = (cells[0].textContent||'EQUIPOS INTERNOS').trim();
        // Obtener d√≠as en servicio desde columna visible
        let dias = 0;
        if (diasServicioVisibleIdx >= 0){
          const td = cells[1 + diasServicioVisibleIdx];
          if (td){
            const s = String(td.textContent||'').replace(/,/g,'').trim();
            const n = parseFloat(s);
            if (!isNaN(n)) dias = n;
          }
        }
        if (dias > 0){
          total++;
          if (tipo === 'EQUIPOS INTERNOS') internos++; else externos++;
        }
      });
      activityCards.innerHTML = '';
      const data = [
        { label: 'Equipos totales en servicio', val: total },
        { label: 'Equipos internos en servicio', val: internos },
        { label: 'Equipos externos en servicio', val: externos }
      ];
      data.forEach(k=>{
        const card = document.createElement('div'); card.className='card';
        const l = document.createElement('div'); l.className='kpi-label'; l.textContent = k.label;
        const v = document.createElement('div'); v.className='kpi'; v.textContent = fmt(k.val);
        card.appendChild(l); card.appendChild(v); activityCards.appendChild(card);
      });
      activityKpis.style.display = '';
    }

    function renderBody(data){
      const frag = document.createDocumentFragment();
      for (let i=0;i<data.length;i++){
        const tr = document.createElement('tr');
        const row = data[i];
        // Celda de selecci√≥n por fila (solo en filas 1 y 4 visibles)
        const tdSel = document.createElement('td');
        // Determinar tipo por PROPIEDAD
        let pre = 'EQUIPOS INTERNOS';
        if (propiedadIdx >= 0){
          const prop = String(row[propiedadIdx]||'').trim().toUpperCase();
          if (prop === 'PCT') pre = 'EQUIPOS INTERNOS';
          else if (prop) pre = 'EQUIPOS EXTERNOS';
        }
        if (i === 0 || i === 3){
          const select = document.createElement('select');
          select.innerHTML = `
            <option value="EQUIPOS INTERNOS">EQUIPOS INTERNOS</option>
            <option value="EQUIPOS EXTERNOS">EQUIPOS EXTERNOS</option>
          `;
          select.value = pre;
          tdSel.appendChild(select);
        } else {
          const tag = document.createElement('span');
          tag.className = 'sel-tag readonly';
          tag.textContent = pre;
          tdSel.appendChild(tag);
        }
        
        // Bot√≥n de editar (solo admin)
        const editBtn = document.createElement('button');
        editBtn.className = 'edit-row-btn';
        editBtn.innerHTML = '‚úèÔ∏è';
        editBtn.title = 'Editar este registro';
        if (!(window.isAdmin && window.isAdmin())) {
          editBtn.style.display = 'none';
        }
        editBtn.addEventListener('click', () => {
          if (!(window.isAdmin && window.isAdmin())) { alert('Solo un administrador puede editar registros.'); return; }
          // Convertir la fila a modo edici√≥n
          makeRowEditable(tr, row, i);
        });
        tdSel.appendChild(editBtn);
        
        // Bot√≥n de eliminar (solo admin)
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'delete-row-btn';
        deleteBtn.innerHTML = 'üóëÔ∏è';
        deleteBtn.title = 'Eliminar este registro';
        if (!(window.isAdmin && window.isAdmin())) {
          deleteBtn.style.display = 'none';
        }
        deleteBtn.addEventListener('click', async () => {
          if (!(window.isAdmin && window.isAdmin())) { alert('Solo un administrador puede eliminar registros.'); return; }
          if (confirm('¬øEst√°s seguro de eliminar este registro permanentemente?')){
            // Eliminar de rows y view
            const rowIndex = rows.indexOf(row);
            if (rowIndex >= 0) {
              // Eliminar de Firestore si tiene ID
              if (row._firestoreId) {
                await deleteFromFirestore(row._firestoreId);
              }
              
              rows.splice(rowIndex, 1);
              view = rows;
              renderBody(view);
              updateKPIs();
              // Actualizar localStorage
              try{
                const keyLS = 'actividad:newRows';
                const cleanRows = rows.map(r => {
                  if (r._firestoreId) {
                    const { _firestoreId, ...rest } = r;
                    return rest;
                  }
                  return r;
                });
                localStorage.setItem(keyLS, JSON.stringify(cleanRows));
              }catch(e){
                console.error('[actividad] Error al actualizar localStorage:', e);
              }
              console.log('[actividad] Registro eliminado correctamente');
            }
          }
        });
        tdSel.appendChild(deleteBtn);
        
        tr.appendChild(tdSel);
        const order = visibleCols ? visibleCols.order : headers.map((_,k)=>k);
        for (let j=0;j<order.length;j++){
          const td = document.createElement('td');
          const idx = order[j];
          let v = idx == null || idx < 0 ? '' : (row[idx] == null ? '' : row[idx]);
          // Formateo de fechas dd/mm/yy -> dd/mm/yyyy (excepto FIN PARCIAL y CONTINUACION que tienen m√∫ltiples fechas)
          const label = (visibleCols ? visibleCols.labels[j] : headers[j]) || '';
          const isMultiDateField = /^(FIN PARCIAL DEL SERVICIO|FIN PARCIAL|CONTINUACION DEL SERVICIO|CONTINUACI√ìN DEL SERVICIO)$/i.test(normalizeHeader(label).toUpperCase());
          if (!isMultiDateField && /fecha\s|inicio del servicio|continuacion del servicio|fin parcial del servicio|terminacion del servicio|devolucion/i.test(label)){
            const s = String(v).trim();
            const m = s.match(/^(\d{1,2})\/(\d{1,2})\/(\d{2,4})$/);
            if (m){
              let d = parseInt(m[1],10), M = parseInt(m[2],10), y = parseInt(m[3],10);
              if (y < 100) y += 2000;
              const dd = String(d).padStart(2,'0');
              const MM = String(M).padStart(2,'0');
              const yy = String(y % 100).padStart(2,'0');
              v = `${dd}/${MM}/${yy}`;
            }
          }
          // Render editable para EQUIPO / ACTIVO
          const isEquipoCol = /^(EQUIPO\s*\/\s*ACTIVO|EQUIPO\s*ACTIVO|EQUIPO)$/i.test(normalizeHeader(label).toUpperCase());
          if (isEquipoCol){
            // Interno/Externo seg√∫n la primera celda
            const selCell = tdSel;
            const selEl = selCell.querySelector('select');
            const tipo = selEl ? selEl.value : (selCell.textContent||'EQUIPOS INTERNOS');
            const input = document.createElement('input');
            input.type = 'text';
            input.value = String(v||'');
            if (tipo === 'EQUIPOS INTERNOS'){
              // Autocompletar desde inventario
              ensureDatalist('dl-inventory-equipos', inventoryOptions||[]);
              input.setAttribute('list', 'dl-inventory-equipos');
              input.placeholder = 'Equipo/Activo (inventario)';
            } else {
              // Autocompletar por proveedor
              input.placeholder = 'Clave del proveedor';
              const prov = propiedadIdx>=0 ? String(row[propiedadIdx]||'').trim().toUpperCase() : '';
              const dlid = 'dl-prov-' + (prov||'GEN');
              const opts = externalOptionsByProvider.get(prov) ? Array.from(externalOptionsByProvider.get(prov).values()) : [];
              ensureDatalist(dlid, opts);
              input.setAttribute('list', dlid);
            }
            td.appendChild(input);
          } else {
            // Autorelleno de DESCRIPCION para internos desde inventario
            const isDescCol = /^DESCRIPCION$/i.test(normalizeHeader(label).toUpperCase()) || /^DESCRIPCI√ìN$/i.test(normalizeHeader(label).toUpperCase());
            if (isDescCol){
              // Determinar tipo por primera celda y equipo de la fila
              const selCell = tdSel;
              const selEl = selCell.querySelector('select');
              const tipo = selEl ? selEl.value : (selCell.textContent||'EQUIPOS INTERNOS');
              // Obtener valor de equipo desde la fila base (headers)
              const idxEquipoHeader = headers.findIndex(h=>/^EQUIPO\s*\/\s*ACTIVO|EQUIPO\s*ACTIVO|EQUIPO$/i.test(normalizeHeader(h).toUpperCase()));
              const equipoVal = idxEquipoHeader>=0 ? String(row[idxEquipoHeader]||'').trim() : '';
              const descInv = invDescByEquipo.get(equipoVal) || invDescByEquipo.get(equipoVal.toUpperCase()) || '';
              if (tipo === 'EQUIPOS INTERNOS' && descInv){ v = descInv; console.log('[actividad] DESC autofill', { equipo: equipoVal, desc: v }); }
              td.textContent = v;
            } else if (/^(SERIAL|#)$/i.test(normalizeHeader(label).toUpperCase())){
              // Autorelleno de SERIAL para internos desde inventario
              const selCell = tdSel;
              const selEl = selCell.querySelector('select');
              const tipo = selEl ? selEl.value : (selCell.textContent||'EQUIPOS INTERNOS');
              const idxEquipoHeader = headers.findIndex(h=>/^EQUIPO\s*\/\s*ACTIVO|EQUIPO\s*ACTIVO|EQUIPO$/i.test(normalizeHeader(h).toUpperCase()));
              const equipoVal = idxEquipoHeader>=0 ? String(row[idxEquipoHeader]||'').trim() : '';
              const serialInv = invSerialByEquipo.get(equipoVal) || invSerialByEquipo.get(equipoVal.toUpperCase()) || '';
              if (tipo === 'EQUIPOS INTERNOS' && serialInv){ v = serialInv; console.log('[actividad] SERIAL autofill', { equipo: equipoVal, serial: v }); }
              td.textContent = v;
            } else if (/^(FIN PARCIAL DEL SERVICIO|FIN PARCIAL|CONTINUACION DEL SERVICIO|CONTINUACI√ìN DEL SERVICIO)$/i.test(normalizeHeader(label).toUpperCase())){
              // FIN PARCIAL y CONTINUACION: mostrar m√∫ltiples l√≠neas
              td.textContent = v;
              td.style.whiteSpace = 'pre-wrap';
              td.style.fontSize = '0.9em';
              td.style.verticalAlign = 'top';
              td.style.lineHeight = '1.4';
            } else {
              td.textContent = v;
            }
          }
          tr.appendChild(td);
        }
        frag.appendChild(tr);
      }
      tbody.innerHTML = '';
      tbody.appendChild(frag);
      count.textContent = fmt(data.length) + ' registros';
      syncScrollbar();
      // recomputar √≠ndices visibles y KPIs
      computeVisibleIndices();
      updateActivityKpis();
    }

    function applyFilter(){
      const term = (q.value||'').trim().toLowerCase();
      if (!term){ view = rows; } else {
        view = rows.filter(r => r.some(c => String(c||'').toLowerCase().includes(term)));
      }
      if (sortCol>=0) applySort();
      renderBody(view);
    }

    function toggleSort(col){
      if (sortCol === col){ sortDir = (sortDir==='asc'?'desc':'asc'); }
      else { sortCol = col; sortDir = 'asc'; }
      applySort();
      renderHead();
      renderBody(view);
    }

    function applySort(){
      const dir = sortDir === 'asc' ? 1 : -1;
      const order = visibleCols ? visibleCols.order : headers.map((_,k)=>k);
      const idx = order[sortCol] ?? sortCol;
      view = [...view].sort((a,b)=>{
        const av = a[idx] ?? '';
        const bv = b[idx] ?? '';
        const an = parseFloat(String(av).replace(/,/g,''));
        const bn = parseFloat(String(bv).replace(/,/g,''));
        const bothNum = !isNaN(an) && !isNaN(bn);
        if (bothNum) return (an>bn?1:an<bn?-1:0)*dir;
        return String(av).localeCompare(String(bv), 'es', { sensitivity:'base' }) * dir;
      });
    }

    function buildVisibleColumns(){
      const wanted = [
        'SERIAL','#',
        'EQUIPO / ACTIVO','EQUIPO/ACTIVO','EQUIPO ACTIVO',
        'DESCRIPCION','DESCRIPCI√ìN',
        'CLIENTE','AREA DEL CLIENTE','UBICACI√ìN',
        'FECHA EMBARQUE',
        'INICIO DEL SERVICIO','CONTINUACION DEL SERVICIO','FIN PARCIAL DEL SERVICIO','TERMINACION DEL SERVICIO','FECHA DE DEVOLUCION',
        'DIAS EN SERVICIO',
        // Precio debe estar visible para poder calcular ingresos/renta
        'PRECIO',
        // Cotizaci√≥n / estimaci√≥n (se mostrar√° como EST-COT) debe ir justo antes de FACTURA
        'COT / ESTIMACION',
        'FACTURA',
        // ORDEN DE SERVICIO (columna "O. S." en el CSV) debe ir antes de ORDEN DE COMPRA
        'O. S.',
        // Variantes comunes para Orden de compra (debe ir entre FACTURA y FECHA EMBARQUE)
        'ORDEN DE COMPRA','ORDEN COMPRA','NO. ORDEN DE COMPRA','NO ORDEN DE COMPRA','N√öMERO DE ORDEN','NUMERO DE ORDEN','OC','ORDEN DE COMRA',
        'INGRESO ACUMULADO','INGRESO ACUMULDDO','RENTA ACUMULADA'
      ];
      const normHeaders = headers.map(h=>normalizeHeader(h).toUpperCase());
      const order = [];
      const labels = [];
      // helper para a√±adir si existe
      function addOne(name){
        const idx = normHeaders.indexOf(normalizeHeader(name).toUpperCase());
        if (idx>=0){ order.push(idx); labels.push(headers[idx]); }
      }
      // construir orden sin duplicar
      const seen = new Set();
      wanted.forEach(name=>{
        const idx = normHeaders.indexOf(normalizeHeader(name).toUpperCase());
        if (idx>=0 && !seen.has(idx)){ order.push(idx); labels.push(headers[idx]); seen.add(idx); }
      });
      if (!order.length){ visibleCols = null; return; }
      // Normalizar etiquetas visibles para variantes conocidas
      const normLabel = (s)=> normalizeHeader(s).toUpperCase();
      const ocVariants = new Set(['ORDEN DE COMPRA','ORDEN COMPRA','NO. ORDEN DE COMPRA','NO ORDEN DE COMPRA','N√öMERO DE ORDEN','NUMERO DE ORDEN','OC','ORDEN DE COMRA']);
      const ingresoTypo = 'INGRESO ACUMULDDO';
      const estCotVariants = new Set(['COT / ESTIMACION','COT/ESTIMACION','COT ESTIMACION','EST-COT']);
      const osVariants = new Set(['O. S.','O.S.','ORDEN DE SERVICIO']);
      for (let k=0; k<labels.length; k++){
        const lnorm = normLabel(labels[k]);
        if (lnorm === '#') labels[k] = 'SERIAL';
        if (ocVariants.has(lnorm)) labels[k] = 'ORDEN DE COMPRA';
        if (lnorm === ingresoTypo) labels[k] = 'INGRESO ACUMULADO';
        if (estCotVariants.has(lnorm)) labels[k] = 'EST-COT';
        if (osVariants.has(lnorm)) labels[k] = 'ORDEN DE SERVICIO';
      }
      // Si no existe DESCRIPCION en headers, insertar columna sint√©tica justo despu√©s de EQUIPO / ACTIVO
      const hasDesc = labels.some(l=>normLabel(l)==='DESCRIPCION');
      if (!hasDesc){
        const eqIdx = labels.findIndex(l=>['EQUIPO / ACTIVO','EQUIPO/ACTIVO','EQUIPO ACTIVO','EQUIPO'].includes(normLabel(l)));
        const insertAt = eqIdx>=0 ? eqIdx+1 : 1;
        labels.splice(insertAt, 0, 'DESCRIPCION');
        order.splice(insertAt, 0, -1); // √≠ndice sint√©tico
      }
      visibleCols = { order, labels };
      propiedadIdx = normHeaders.indexOf('PROPIEDAD');
      computeVisibleIndices();
    }

    function syncScrollbar(){
      const scroller = document.querySelector('.table-scroll');
      const bar = document.querySelector('.scrollbar-x');
      const content = bar.querySelector('.scrollbar-content');
      content.style.width = table.scrollWidth + 'px';
      bar.scrollLeft = scroller.scrollLeft;
      bar.onscroll = () => { scroller.scrollLeft = bar.scrollLeft; };
      scroller.onscroll = () => { bar.scrollLeft = scroller.scrollLeft; };
      let dragging = false; let startX=0; let startLeft=0;
      bar.addEventListener('mousedown', (e)=>{ dragging=true; startX=e.clientX; startLeft=bar.scrollLeft; document.getElementById('inventory-wrapper').classList.add('dragging'); });
      window.addEventListener('mousemove', (e)=>{ if(!dragging) return; const dx=e.clientX-startX; bar.scrollLeft = startLeft + dx; });
      window.addEventListener('mouseup', ()=>{ if(dragging){ dragging=false; document.getElementById('inventory-wrapper').classList.remove('dragging'); }});
    }

    // Recalculo diferido para evitar desajuste inicial de la primera columna (fuentes/estilos as√≠ncronos)
    function deferReflowFix(){
      // M√∫ltiples intentos con delays incrementales para asegurar render correcto
      const rerender = () => { renderHead(); renderBody(view); syncScrollbar(); };
      
      // Ajustes inmediatos
      requestAnimationFrame(rerender);
      requestAnimationFrame(() => requestAnimationFrame(rerender));
      
      // Delays progresivos (50ms, 150ms, 300ms, 500ms)
      [50, 150, 300, 500].forEach(delay => setTimeout(rerender, delay));
      
      // Cuando terminen de cargar las fuentes web
      if (document.fonts && document.fonts.ready){
        document.fonts.ready.then(() => {
          rerender();
          setTimeout(rerender, 100);
        });
      }
      
      // Al cargar completamente la ventana (√∫ltimo recurso)
      window.addEventListener('load', () => {
        rerender();
        setTimeout(rerender, 100);
      }, { once:true });
    }

    function normalizeHeader(h){
      return String(h||'')
        .normalize('NFD')
        .replace(/[\u0300-\u036f]/g,'')
        .replace(/\s+/g,' ')
        .trim();
    }

    function isLikelyHeaderRow(row){
      const norm = row.map(normalizeHeader);
      const hope = ['equipo / activo','equipo/activo','equipo activo','descripcion','descripci√≥n','producto'];
      let hits = 0;
      for (const h of hope){ if (norm.some(c => c.toLowerCase() === h)) hits++; }
      return hits >= 2; // al menos 2 columnas clave
    }

    function parseSummary(data){
      const kv = {};
      const want = [
        'INGRESOS ACUMULADOS EN EL MES',
        'EQUIPOS TOTALES EN SERVICIO',
        'EQUIPOS PROPIOS EN SERVICIO',
        'EQUIPOS DE TERCEROS EN SERVICIO'
      ];
      for (const row of data){
        const label = (row[0]||'').toString().trim();
        const labelNorm = normalizeHeader(label).toUpperCase();
        if (!labelNorm) continue;
        if (want.includes(labelNorm)){
          // buscar primer numero en la fila
          let val = null;
          for (let j=1;j<row.length;j++){
            const s = String(row[j]||'').replace(/,/g,'');
            const n = parseFloat(s);
            if (!isNaN(n)) { val = n; break; }
          }
          if (val != null) kv[labelNorm] = val;
        }
      }
      return kv;
    }

    function renderSummaryCards(kv){
      const mapTitles = {
        'INGRESOS ACUMULADOS EN EL MES': 'Ingresos acumulados (mes)',
        'EQUIPOS TOTALES EN SERVICIO': 'Equipos en servicio (total)',
        'EQUIPOS PROPIOS EN SERVICIO': 'Propios en servicio',
        'EQUIPOS DE TERCEROS EN SERVICIO': 'Terceros en servicio'
      };
      const items = Object.keys(kv);
      if (!items.length){ summary.style.display='none'; summaryCards.innerHTML=''; return; }
      summary.style.display='';
      summaryCards.innerHTML = '';
      items.forEach(key => {
        const card = document.createElement('div');
        card.className = 'card';
        const label = document.createElement('div'); label.className='kpi-label'; label.textContent = mapTitles[key] || key;
        const val = document.createElement('div'); val.className='kpi'; val.textContent = (kv[key]).toLocaleString('es-MX');
        card.appendChild(label); card.appendChild(val);
        summaryCards.appendChild(card);
      });
    }

    function buildExternalOptionsBase(){
      externalOptionsByProvider.clear();
      const idxEquipo = headers.findIndex(h=>/^EQUIPO\s*\/\s*ACTIVO|EQUIPO\s*ACTIVO|EQUIPO$/i.test(normalizeHeader(h).toUpperCase()));
      for (const r of rows){
        const prov = propiedadIdx>=0 ? String(r[propiedadIdx]||'').trim().toUpperCase() : '';
        const key = idxEquipo>=0 ? String(r[idxEquipo]||'').trim() : '';
        if (!prov || !key) continue;
        if (!externalOptionsByProvider.has(prov)) externalOptionsByProvider.set(prov, new Set());
        externalOptionsByProvider.get(prov).add(key);
      }
    }

    function loadInventoryOptions(){
      const url = INVENT_SRC;
      Papa.parse(url, { download:true, skipEmptyLines:'greedy', complete:(res)=>{
        try{
          const r = res?.data || [];
          if (!r.length){ console.log('[actividad] Inventario vac√≠o', url); return; }
          const hdr = r[0].map(h=>String(h||''));
          let idxEq = -1, idxDesc = -1, idxSerial = -1;
          for (let k=0;k<hdr.length;k++){
            const h = hdr[k];
            if (/^EQUIPO\s*\/\s*ACTIVO|EQUIPO\s*ACTIVO|EQUIPO$/i.test(normalizeHeader(h).toUpperCase())) { idxEq = k; break; }
          }
          for (let k=0;k<hdr.length;k++){
            const h = hdr[k];
            if (/^DESCRIPCION|DESCRIPCI√ìN$/i.test(normalizeHeader(h).toUpperCase())) { idxDesc = k; break; }
          }
          for (let k=0;k<hdr.length;k++){
            const h = hdr[k];
            const hnorm = normalizeHeader(h).toUpperCase();
            // Priorizar SERIAL sobre otras variantes, excluir # ya que es ID de fila
            if (hnorm === 'SERIAL') { idxSerial = k; break; }
          }
          if (idxSerial < 0){
            for (let k=0;k<hdr.length;k++){
              const h = hdr[k];
              if (/^(SERIE|NUMERO DE SERIE|N√öMERO DE SERIE|SERIAL NO|NO\. SERIE|NO DE SERIE|N DE SERIE|NUM DE SERIE)$/i.test(normalizeHeader(h).toUpperCase())) { idxSerial = k; break; }
            }
          }
          const set = new Set();
          invDescByEquipo.clear();
          invSerialByEquipo.clear();
          for (let rIdx=1;rIdx<r.length;rIdx++){
            const v = String(r[rIdx][idxEq]||'').trim();
            if (v) set.add(v);
            if (idxEq>=0 && idxDesc>=0){
              const desc = String(r[rIdx][idxDesc]||'').trim();
              if (v && desc) invDescByEquipo.set(v, desc);
            }
            if (idxEq>=0 && idxSerial>=0){
              const serial = String(r[rIdx][idxSerial]||'').trim();
              if (v && serial) invSerialByEquipo.set(v, serial);
            }
          }
          inventoryOptions = Array.from(set.values()).sort((a,b)=>a.localeCompare(b,'es'));
          inventorySet = new Set(inventoryOptions);
          console.log('[actividad] Inventario unificado cargado', { url, equipos: inventoryOptions.length, desc: invDescByEquipo.size, serial: invSerialByEquipo.size, idxEq, idxDesc, idxSerial });
          // Evitar re-render si hay una fila en edici√≥n (new-row)
          if (tbody.children.length && !tbody.querySelector('tr.new-row')) {
            renderBody(view);
            syncScrollbar();
          }
        } catch(e){ console.error('[actividad] Error parse inventario', e); }
      }, error:(e)=>{ console.log('[actividad] Papa.parse error', { url, error:e }); }});
    }

    async function load(){
      // Inicializar Firebase
      try {
        await waitForFirebase();
        console.log('[actividad] Firebase inicializado correctamente');
      } catch (e) {
        console.warn('[actividad] Firebase no disponible, usando localStorage √∫nicamente');
      }
      
      Papa.parse(SRC, {
        download: true,
        skipEmptyLines: 'greedy',
        complete: (res)=>{
          const data = res.data || [];
          if (!data.length){ headers=[]; rows=[]; view=[]; renderHead(); renderBody([]); renderSummaryCards({}); return; }
          // Buscar fila de cabecera real
          let headerIdx = -1;
          for (let i=0;i<Math.min(data.length, 20); i++){
            if (isLikelyHeaderRow(data[i])) { headerIdx = i; break; }
          }
          // Extraer resumen de las filas previas
          const pre = headerIdx>0 ? data.slice(0, headerIdx) : [];
          const summaryKV = parseSummary(pre);
          renderSummaryCards(summaryKV);

          // Cabecera y filas de detalle
          if (headerIdx >= 0){
            headers = data[headerIdx].map(h=>String(h||''));
            rows = data.slice(headerIdx+1);
          } else {
            headers = data[0].map(h=>String(h||''));
            rows = data.slice(1);
          }
          buildVisibleColumns();
          view = rows;
          // Mezclar registros guardados en localStorage (persistencia simple en cliente)
          try{
            const keyLS = 'actividad:newRows';
            const extra = JSON.parse(localStorage.getItem(keyLS)||'[]');
            if (Array.isArray(extra) && extra.length){
              rows = [...extra, ...rows];
            }
          }catch{}
          buildExternalOptionsBase();
          renderHead();
          renderBody(view);
          // Forzar reflujo para corregir ancho/alineaci√≥n de primera columna sin hard reload
          deferReflowFix();
          // Escuchar cambios en selects para refrescar KPIs y actualizar editor de EQUIPO/ACTIVO en sitio
          tbody.addEventListener('change', (e)=>{
            if (!e.target) return;
            if (e.target.tagName === 'SELECT'){
              // Si cambia el tipo Interno/Externo, actualizar solo la fila
              const tr = e.target.closest('tr');
              if (tr) rebuildEquipoCellForRow(tr);
              updateActivityKpis();
            }
          });
          // Escuchar entradas en EQUIPO/ACTIVO para actualizar etiqueta gris
          tbody.addEventListener('input', (e)=>{
            const target = e.target;
            if (!(target instanceof HTMLInputElement)) return;
            // localizar la fila y su primera celda
            const tr = target.closest('tr');
            if (!tr) return;
            const firstCell = tr.children[0];
            if (!firstCell) return;
            const tag = firstCell.querySelector('span.sel-tag.readonly');
            if (!tag) return; // solo auto-actualizamos en filas sin selector
            const val = String(target.value||'').trim();
            if (!val){ tag.textContent = 'EQUIPOS INTERNOS'; return; }
            const isInternal = inventorySet.has(val);
            tag.textContent = isInternal ? 'EQUIPOS INTERNOS' : 'EQUIPOS EXTERNOS';
            // Si se est√° editando EQUIPO/ACTIVO y la columna DESCRIPCION existe, auto-rellenar para internos
            const headerLabels = (visibleCols ? visibleCols.labels : headers).map(x=>normalizeHeader(x).toUpperCase());
            const isEquipoInput = target && headerLabels[(Array.from(tr.children).indexOf(target.closest('td')) - 1)] && /^(EQUIPO \/ ACTIVO|EQUIPO\/ACTIVO|EQUIPO ACTIVO|EQUIPO)$/.test(headerLabels[(Array.from(tr.children).indexOf(target.closest('td')) - 1)]);
            if (isEquipoInput && descripcionVisibleIdx >= 0){
              const descTd = tr.children[1 + descripcionVisibleIdx];
              if (descTd){
                const newDesc = (isInternal && invDescByEquipo.get(val)) ? invDescByEquipo.get(val) : (descTd.textContent||'');
                descTd.textContent = newDesc; if (isInternal) console.log('[actividad] DESC onInput', { equipo: val, desc: newDesc });
              }
            }
            // Si se est√° editando EQUIPO/ACTIVO y existe columna SERIAL, auto-rellenar serial para internos
            if (isEquipoInput && serialVisibleIdx >= 0){
              const serialTd = tr.children[1 + serialVisibleIdx];
              if (serialTd){
                const newSerial = (isInternal && invSerialByEquipo.get(val)) ? invSerialByEquipo.get(val) : (serialTd.textContent||'');
                serialTd.textContent = newSerial; if (isInternal) console.log('[actividad] SERIAL onInput', { equipo: val, serial: newSerial });
              }
            }
          });
          // Cargar opciones de inventario en paralelo
          loadInventoryOptions();
        }
      });
    }
      // Utilidades para fechas
      function parseDMY(s){
        const m = String(s||'').trim().match(/^(\d{1,2})\/(\d{1,2})\/(\d{2,4})$/);
        if (!m) return null;
        let d = parseInt(m[1],10), M = parseInt(m[2],10)-1, y = parseInt(m[3],10);
        if (y<100) y+=2000;
        const dt = new Date(y, M, d);
        return isNaN(dt.getTime()) ? null : dt;
      }
      function formatDMY(dt){
        const d = String(dt.getDate()).padStart(2,'0');
        const m = String(dt.getMonth()+1).padStart(2,'0');
        const y2 = String(dt.getFullYear() % 100).padStart(2,'0');
        return `${d}/${m}/${y2}`;
      }

    function headerIndex(nameVariants){
      const hdr = headers.map(h=>normalizeHeader(h).toUpperCase());
      for (const v of nameVariants){
        const i = hdr.indexOf(v); if (i>=0) return i;
      }
      return -1;
    }

    // Editor de fecha con m√°scara: usuario teclea 6 d√≠gitos (ddmmyy) ‚Üí muestra dd/mm/yy
    function buildDateEditor(disabled=false, presetStr=''){
      // presetStr puede venir como dd/mm/aa o dd/mm/aaaa
      const preset = parseDMY(presetStr) || new Date();
      const input = document.createElement('input');
      input.type = 'text';
      input.className = 'date-input-masked';
      input.maxLength = 8; // dd/mm/yy
      input.placeholder = 'dd/mm/yy';
      
      // Valor inicial formateado
      const dd = String(preset.getDate()).padStart(2,'0');
      const mm = String(preset.getMonth()+1).padStart(2,'0');
      const yy = String(preset.getFullYear()%100).padStart(2,'0');
      input.value = `${dd}/${mm}/${yy}`;
      
      // M√°scara autom√°tica mientras escribe
      input.addEventListener('input', (e) => {
        let value = e.target.value.replace(/\D/g, ''); // Solo d√≠gitos
        if (value.length > 6) value = value.slice(0, 6); // M√°ximo 6 d√≠gitos
        
        // Formatear autom√°ticamente: ddmmyy ‚Üí dd/mm/yy
        let formatted = '';
        if (value.length >= 1) formatted += value.slice(0, 2);
        if (value.length >= 3) formatted += '/' + value.slice(2, 4);
        if (value.length >= 5) formatted += '/' + value.slice(4, 6);
        
        e.target.value = formatted;
      });
      
      // Permitir navegaci√≥n con teclado sin interferir
      input.addEventListener('keydown', (e) => {
        // Permitir: backspace, delete, tab, escape, enter, flechas
        if ([8, 9, 27, 13, 46, 37, 38, 39, 40].includes(e.keyCode)) return;
        // Permitir: Ctrl+A, Ctrl+C, Ctrl+V, Ctrl+X
        if ((e.ctrlKey || e.metaKey) && [65, 67, 86, 88].includes(e.keyCode)) return;
        // Solo n√∫meros
        if ((e.keyCode < 48 || e.keyCode > 57) && (e.keyCode < 96 || e.keyCode > 105)) {
          e.preventDefault();
        }
      });
      
      if (disabled) {
        input.disabled = true;
        input.title = 'Se calcula autom√°ticamente (regla 25/27)';
        input.style.opacity = '0.6';
      }
      
      return { wrap: input, hidden: input }; // input act√∫a como wrap y hidden
    }

    // Estado de edici√≥n actual
    let currentNewRowEl = null;
    let currentEditors = null;
    let currentSelTipo = null;
    let currentProvInput = null;

    function setToolbarEditing(on){
      if (on){
        saveRowBtn.style.display='';
        saveRowBtn.disabled = true;
        saveRowBtn.style.opacity='.6';
        saveRowBtn.style.pointerEvents='none';
        cancelRowBtn.style.display='';
        newRowBtn.disabled = true;
        newRowBtn.style.opacity='.5';
      } else {
        saveRowBtn.style.display='none';
        saveRowBtn.disabled = false;
        saveRowBtn.style.opacity='1';
        saveRowBtn.style.pointerEvents='auto';
        cancelRowBtn.style.display='none';
        newRowBtn.disabled = false;
        newRowBtn.style.opacity='1';
      }
    }

    // Helper: obtener editor por variantes de nombre (usando normalizaci√≥n de encabezados)
    function getEditorByVariants(eds, variants){
      if (!eds) return null;
      const keys = Object.keys(eds);
      for (const v of variants){
        const nv = normalizeHeader(v).toUpperCase();
        for (const k of keys){ if (k === nv) return eds[k]; }
      }
      return null;
    }

    function isValidNewRow(){
      if (!currentEditors || !currentSelTipo) {
        console.log('[actividad] Validaci√≥n fall√≥: no hay editores o tipo');
        return false;
      }
      const tipo = currentSelTipo.value;
      const equipo = getEditorByVariants(currentEditors, ['EQUIPO / ACTIVO','EQUIPO/ACTIVO','EQUIPO ACTIVO','EQUIPO'])?.value || '';
      const inicio = getEditorByVariants(currentEditors, ['INICIO DEL SERVICIO'])?.value || '';
      const term = getEditorByVariants(currentEditors, ['TERMINACION DEL SERVICIO','TERMINACI√ìN DEL SERVICIO'])?.value || '';
      console.log('[actividad] Validaci√≥n campos:', { equipo, inicio, term, tipo });
      if (!equipo || !inicio || !term) {
        console.log('[actividad] Validaci√≥n fall√≥: falta equipo, inicio o terminaci√≥n');
        return false;
      }
      if (tipo==='EQUIPOS EXTERNOS' && currentProvInput && !currentProvInput.value) {
        console.log('[actividad] Validaci√≥n fall√≥: falta proveedor para equipo externo');
        return false;
      }
      const di = parseDMY(inicio); const dt = parseDMY(term);
      console.log('[actividad] Fechas parseadas:', { inicio, di, term, dt, dtMenorDi: dt < di });
      if (!di || !dt || dt < di) {
        console.log('[actividad] Validaci√≥n fall√≥: fechas inv√°lidas o terminaci√≥n antes de inicio');
        return false;
      }
      console.log('[actividad] ‚úÖ Validaci√≥n OK - Bot√≥n Guardar habilitado');
      return true;
    }

    function updateSaveEnabled(){
      const ok = isValidNewRow();
      saveRowBtn.disabled = !ok;
      saveRowBtn.style.opacity = ok ? '1' : '.6';
      saveRowBtn.style.pointerEvents = ok ? 'auto' : 'none';
    }

    function makeRowEditable(tr, row, rowIndex){
      // Evitar editar si ya hay una fila en edici√≥n
      if (tbody.querySelector('tr.editing-row') || tbody.querySelector('tr.new-row')) {
        alert('Ya hay una fila en edici√≥n. Guarda o cancela primero.');
        return;
      }
      
      tr.classList.add('editing-row');
      const cells = tr.querySelectorAll('td');
      const order = visibleCols ? visibleCols.order : headers.map((_,k)=>k);
      const labels = visibleCols ? visibleCols.labels : headers;
      const editors = {};
      
      // Primera celda: mantener select de tipo + agregar botones Guardar/Cancelar
      const firstCell = cells[0];
      const selEl = firstCell.querySelector('select') || firstCell.querySelector('.sel-tag');
      const tipoValue = selEl ? (selEl.value || selEl.textContent) : 'EQUIPOS INTERNOS';
      
      // Limpiar y reconstruir primera celda
      firstCell.innerHTML = '';
      const sel = document.createElement('select');
      sel.innerHTML = '<option value="EQUIPOS INTERNOS">EQUIPOS INTERNOS</option><option value="EQUIPOS EXTERNOS">EQUIPOS EXTERNOS</option>';
      sel.value = tipoValue;
      firstCell.appendChild(sel);
      
      // Botones Guardar/Cancelar
      const saveBtn = document.createElement('button');
      saveBtn.textContent = 'üíæ';
      saveBtn.className = 'save-edit-btn';
      saveBtn.title = 'Guardar cambios';
      
      const cancelBtn = document.createElement('button');
      cancelBtn.textContent = '‚úñ';
      cancelBtn.className = 'cancel-edit-btn';
      cancelBtn.title = 'Cancelar edici√≥n';
      
      firstCell.appendChild(saveBtn);
      firstCell.appendChild(cancelBtn);
      
      // Convertir celdas a inputs (excepto auto-generadas)
      for (let j=0; j<order.length; j++){
        const td = cells[j+1]; // +1 porque cells[0] es SELECCI√ìN
        if (!td) continue;
        
        const label = labels[j] || '';
        const norm = normalizeHeader(label).toUpperCase();
        const idx = order[j];
        let val = idx >= 0 && idx < row.length ? (row[idx] || '') : '';
        
        // Campos no editables (auto-generados)
        if (/^(SERIAL|#|DESCRIPCION|DESCRIPCI√ìN|FECHA DE DEVOLUCION|FECHA DE DEVOLUCI√ìN|INGRESO ACUMULADO|RENTA ACUMULADA)$/i.test(norm)){
          td.style.fontStyle = 'italic';
          td.style.color = '#6b7280';
          editors[norm] = td;
          continue;
        }
        
        // Campos de fecha
        if (/fecha|inicio del servicio|terminacion del servicio/i.test(label)){
          const input = document.createElement('input');
          input.type = 'text';
          input.className = 'date-input-masked';
          input.maxLength = 8;
          input.placeholder = 'dd/mm/yy';
          input.value = String(val);
          // Agregar listeners de m√°scara
          input.addEventListener('input', (e) => {
            let value = e.target.value.replace(/\D/g, '');
            if (value.length > 6) value = value.slice(0, 6);
            let formatted = '';
            if (value.length >= 1) formatted += value.slice(0, 2);
            if (value.length >= 3) formatted += '/' + value.slice(2, 4);
            if (value.length >= 5) formatted += '/' + value.slice(4, 6);
            e.target.value = formatted;
          });
          td.innerHTML = '';
          td.appendChild(input);
          editors[norm] = input;
          continue;
        }
        
        // DIAS EN SERVICIO (n√∫mero, auto-calculado pero puede editarse)
        if (/dias en servicio/i.test(label)){
          const input = document.createElement('input');
          input.type = 'number';
          input.min = '0';
          input.value = String(val);
          td.innerHTML = '';
          td.appendChild(input);
          editors[norm] = input;
          continue;
        }
        
        // PRECIO (n√∫mero)
        if (/precio/i.test(label)){
          const input = document.createElement('input');
          input.type = 'number';
          input.min = '0';
          input.step = '0.01';
          input.value = String(val);
          td.innerHTML = '';
          td.appendChild(input);
          editors[norm] = input;
          continue;
        }
        
        // Resto de campos (texto)
        const input = document.createElement('input');
        input.type = 'text';
        input.value = String(val);
        td.innerHTML = '';
        td.appendChild(input);
        editors[norm] = input;
      }
      
      // Guardar cambios
      saveBtn.onclick = async () => {
        // Actualizar row con los nuevos valores
        for (let j=0; j<order.length; j++){
          const norm = normalizeHeader(labels[j]).toUpperCase();
          const editor = editors[norm];
          if (editor && editor.value !== undefined){
            const idx = order[j];
            if (idx >= 0) row[idx] = editor.value;
          }
        }
        
        // Actualizar tipo (PROPIEDAD)
        if (propiedadIdx >= 0){
          row[propiedadIdx] = sel.value === 'EQUIPOS INTERNOS' ? 'PCT' : 'PROVEEDOR';
        }
        
        // Actualizar en Firestore si tiene ID
        if (firebaseReady && window.db && row._firestoreId) {
          try {
            const rowData = [...row];
            delete rowData._firestoreId;
            await window.db.collection(COLLECTION_NAME).doc(row._firestoreId).update({
              row: rowData,
              timestamp: firebase.firestore.FieldValue.serverTimestamp(),
              updatedAt: new Date().toISOString()
            });
            console.log('[actividad] Registro actualizado en Firestore');
          } catch (e) {
            console.error('[actividad] Error al actualizar en Firestore:', e);
          }
        }
        
        // Re-renderizar
        renderBody(view);
        updateKPIs();
        
        // Guardar en localStorage
        try{
          const keyLS = 'actividad:newRows';
          const cleanRows = rows.map(r => {
            if (r._firestoreId) {
              const { _firestoreId, ...rest } = r;
              return rest;
            }
            return r;
          });
          localStorage.setItem(keyLS, JSON.stringify(cleanRows));
        }catch(e){
          console.error('[actividad] Error al guardar:', e);
        }
        
        console.log('[actividad] Registro actualizado correctamente');
      };
      
      // Cancelar edici√≥n
      cancelBtn.onclick = () => {
        renderBody(view);
      };
    }

    function insertNewEditableRow(){
      // Evitar m√∫ltiples filas nuevas simult√°neas
      if (tbody.querySelector('tr.new-row')) return;
      const tr = document.createElement('tr');
      tr.className = 'new-row';

      // Primera celda: selecci√≥n + proveedor (si externo) + acciones
      const tdSel = document.createElement('td');
      tdSel.className = 'sel-cell';
      const sel = document.createElement('select');
      sel.innerHTML = '<option value="EQUIPOS INTERNOS">EQUIPOS INTERNOS</option><option value="EQUIPOS EXTERNOS">EQUIPOS EXTERNOS</option>';
      sel.name = 'tipoSeleccion'; sel.id = 'tipoSeleccion';
      sel.value = 'EQUIPOS INTERNOS';
      const provInput = document.createElement('input');
      provInput.type = 'text'; provInput.placeholder = 'Proveedor'; provInput.name='proveedor'; provInput.id='proveedor';
      provInput.style.marginLeft='6px'; provInput.style.display='none';
      sel.addEventListener('change', ()=>{ provInput.style.display = sel.value==='EQUIPOS EXTERNOS' ? '' : 'none'; rebuildEquipoCellForRow(tr); updateSaveEnabled(); });
      tdSel.appendChild(sel); tdSel.appendChild(provInput);
      tr.appendChild(tdSel);

      // Construir celdas visibles con inputs
      const order = visibleCols ? visibleCols.order : headers.map((_,k)=>k);
      const labels = visibleCols ? visibleCols.labels : headers;
      const editors = {};
      for (let j=0;j<order.length;j++){
        const td = document.createElement('td');
        const label = labels[j] || '';
        const norm = normalizeHeader(label).toUpperCase();
        let input;
        
        // SERIAL, DESCRIPCION y FECHA DE DEVOLUCION son solo lectura (texto plano, no inputs)
        if (/^(SERIAL|#|DESCRIPCION|DESCRIPCI√ìN)$/.test(norm)){
          td.textContent = ''; // Se autocompletar√° desde el inventario
          td.style.color = '#6b7280'; // Color m√°s suave para indicar que es auto-generado
          td.style.fontStyle = 'italic';
          tr.appendChild(td);
          editors[norm] = td; // Guardamos el td en lugar de input para poder actualizarlo
          continue;
        }
        
        // FIN PARCIAL y CONTINUACION: celdas con m√∫ltiples l√≠neas visibles
        if (/^(FIN PARCIAL DEL SERVICIO|FIN PARCIAL|CONTINUACION DEL SERVICIO|CONTINUACI√ìN DEL SERVICIO)$/i.test(norm)){
          td.textContent = '';
          td.style.whiteSpace = 'pre-wrap'; // Mostrar saltos de l√≠nea
          td.style.color = '#6b7280';
          td.style.fontStyle = 'italic';
          td.style.fontSize = '0.9em';
          td.style.verticalAlign = 'top';
          tr.appendChild(td);
          editors[norm] = td;
          continue;
        }
        
        // FECHA DE DEVOLUCION: auto-calculada como terminaci√≥n + 1 d√≠a
        if (/fecha de devolucion|fecha de devoluci√≥n/i.test(label)){
          td.textContent = ''; // Se calcular√° autom√°ticamente
          td.style.color = '#6b7280';
          td.style.fontStyle = 'italic';
          tr.appendChild(td);
          editors[norm] = td;
          continue;
        }
        
        // INGRESO ACUMULADO y RENTA ACUMULADA: auto-calculados como d√≠as √ó precio
        if (/ingreso acumulado|renta acumulada/i.test(label)){
          td.textContent = ''; // Se calcular√° autom√°ticamente
          td.style.color = '#6b7280';
          td.style.fontStyle = 'italic';
          td.style.textAlign = 'right'; // Alinear montos a la derecha
          tr.appendChild(td);
          editors[norm] = td;
          continue;
        }
        
        if (/^(EQUIPO\s*\/\s*ACTIVO|EQUIPO\s*ACTIVO|EQUIPO)$/.test(norm)){
          input = document.createElement('input'); input.type='text'; input.placeholder='Equipo/Activo'; input.name='equipoActivo'; input.id='equipoActivo';
          // aplicar datalist seg√∫n tipo
          ensureDatalist('dl-inventory-equipos', inventoryOptions||[]);
          input.setAttribute('list', sel.value==='EQUIPOS INTERNOS' ? 'dl-inventory-equipos' : '');
          sel.addEventListener('change', ()=>{
            if (sel.value==='EQUIPOS INTERNOS') input.setAttribute('list','dl-inventory-equipos'); else input.removeAttribute('list');
          });
        } else if (/^(CLIENTE|AREA DEL CLIENTE|UBICACION|UBICACI√ìN)$/.test(norm)){
          input = document.createElement('input'); input.type='text'; input.placeholder=label; input.name=normalizeHeader(label); input.id=normalizeHeader(label);
        } else if (/fecha|inicio del servicio|continuacion del servicio|fin parcial del servicio|terminacion del servicio|devolucion/i.test(label)){
          const isCont = /continuacion del servicio/i.test(label);
          const isFinP = /fin parcial del servicio/i.test(label);
          const ed = buildDateEditor((isCont||isFinP));
          if (isCont) { ed.wrap.style.visibility = 'hidden'; }
          input = ed.hidden; input.name=normalizeHeader(label); input.id=normalizeHeader(label);
          td.appendChild(ed.wrap);
          tr.appendChild(td);
          editors[norm] = input;
          input.addEventListener('input', updateSaveEnabled);
          input.addEventListener('change', updateSaveEnabled);
          continue; // ya a√±adimos td y listeners
        } else if (norm === 'DIAS EN SERVICIO'){
          input = document.createElement('input'); input.type='number'; input.min='0'; input.placeholder='0'; input.name='diasServicio'; input.id='diasServicio';
        } else if (norm === 'PRECIO'){
          input = document.createElement('input'); input.type='number'; input.min='0'; input.step='0.01'; input.placeholder='0.00'; input.name='precio'; input.id='precio';
        } else {
          input = document.createElement('input'); input.type='text'; input.placeholder=label; input.name=normalizeHeader(label); input.id=normalizeHeader(label);
        }
        td.appendChild(input);
        tr.appendChild(td);
        editors[norm] = input;
        input.addEventListener('input', updateSaveEnabled);
        input.addEventListener('change', updateSaveEnabled);
      }

      // Auto-relleno desde inventario al cambiar Equipo/Activo
      const equipoEditor = getEditorByVariants(editors, ['EQUIPO / ACTIVO','EQUIPO/ACTIVO','EQUIPO ACTIVO','EQUIPO']);
      if (equipoEditor){
        const autoFillFromEquipo = () => {
          const keyRaw = String(equipoEditor.value||'').trim();
          if (!keyRaw) return;
          const keyUpper = keyRaw.toUpperCase();
          const descEditor = getEditorByVariants(editors, ['DESCRIPCION','DESCRIPCI√ìN']);
          const serialEditor = getEditorByVariants(editors, ['SERIAL','#']);
          const descInv = invDescByEquipo.get(keyRaw) || invDescByEquipo.get(keyUpper) || '';
          const serialInv = invSerialByEquipo.get(keyRaw) || invSerialByEquipo.get(keyUpper) || '';
          // Ahora son <td> no <input>, usar textContent
          if (descEditor && descInv) descEditor.textContent = descInv;
          if (serialEditor && serialInv) serialEditor.textContent = serialInv;
          console.log('[actividad] Autofill nuevo registro', { equipo: keyRaw, desc: descInv, serial: serialInv });
          updateSaveEnabled();
        };
        equipoEditor.addEventListener('change', autoFillFromEquipo);
        equipoEditor.addEventListener('input', autoFillFromEquipo);
      }

      // Insertar al inicio de tbody
      if (tbody.firstChild) tbody.insertBefore(tr, tbody.firstChild); else tbody.appendChild(tr);
      // Nota: en la fila nueva NO llamamos a rebuildEquipoCellForRow(tr)
      // para no reemplazar el input de EQUIPO/ACTIVO que ya tiene
      // el listener que autocompleta DESCRIPCION y SERIAL desde inventario.
      setToolbarEditing(true);
      currentNewRowEl = tr; currentEditors = editors; currentSelTipo = sel; currentProvInput = provInput;
      updateSaveEnabled();

      // Auto-c√°lculo de d√≠as en servicio, fecha de devoluci√≥n, ingreso y renta
      const inicio = editors['INICIO DEL SERVICIO'];
      const termin = editors['TERMINACION DEL SERVICIO'] || editors['TERMINACI√ìN DEL SERVICIO'];
      const finParcial = editors['FIN PARCIAL DEL SERVICIO'];
      const continuacion = editors['CONTINUACION DEL SERVICIO'] || editors['CONTINUACI√ìN DEL SERVICIO'];
      const dias = editors['DIAS EN SERVICIO'];
      const devolucion = editors['FECHA DE DEVOLUCION'] || editors['FECHA DE DEVOLUCI√ìN'];
      const precio = editors['PRECIO'];
      const ingresoAcum = editors['INGRESO ACUMULADO'] || editors['INGRESO ACUMULDDO'];
      const rentaAcum = editors['RENTA ACUMULADA'];
      
      function recomputeDias(){
        if (!inicio || !termin || !dias) return;
        const di = parseDMY(inicio.value); const dt = parseDMY(termin.value);
        if (!di || !dt) { dias.value = ''; return; }
        const today = new Date(); today.setHours(0,0,0,0);
        if (today < di){
          // cuenta regresiva negativa hasta el d√≠a de inicio
          const neg = -Math.ceil((di - today)/(1000*60*60*24));
          dias.value = String(neg);
        } else {
          // d√≠as en servicio transcurridos hasta hoy o terminaci√≥n (lo que ocurra primero)
          const upto = today <= dt ? today : dt;
          const diff = Math.ceil((upto - di)/(1000*60*60*24)) + 1; // inclusivo desde inicio
          dias.value = String(diff);
        }
      }
      
      function recomputeDevolucion(){
        if (!termin || !devolucion) return;
        const dt = parseDMY(termin.value);
        if (!dt) { devolucion.textContent = ''; return; }
        // Devoluci√≥n = terminaci√≥n + 1 d√≠a
        const dDev = new Date(dt);
        dDev.setDate(dDev.getDate() + 1);
        devolucion.textContent = formatDMY(dDev);
      }
      
      function recomputeFinParcialesContinuacion(){
        if (!inicio || !termin) return;
        const di = parseDMY(inicio.value); const dt = parseDMY(termin.value);
        if (!di || !dt || dt <= di) { 
          if (finParcial) finParcial.textContent = '';
          if (continuacion) continuacion.textContent = '';
          return; 
        }
        const fins = [];
        const conts = [];
        // Primera fecha fin parcial = inicio + 25 d√≠as
        let cursor = new Date(di);
        cursor.setDate(cursor.getDate() + 25);
        cursor.setHours(0,0,0,0);
        while (cursor < dt){
          fins.push(formatDMY(cursor));
          // Continuaci√≥n = d√≠a siguiente
          const cont = new Date(cursor);
          cont.setDate(cont.getDate() + 1);
          conts.push(formatDMY(cont));
          // Siguiente fin parcial = actual + 30 d√≠as
          cursor.setDate(cursor.getDate() + 30);
        }
        if (finParcial) finParcial.textContent = fins.join('\n');
        if (continuacion) continuacion.textContent = conts.join('\n');
      }
      
      function recomputeIngresoRenta(){
        if (!dias || !precio) return;
        const d = parseFloat(dias.value) || 0;
        const p = parseFloat(precio.value) || 0;
        const total = d * p;
        const tipo = sel.value;
        
        // INGRESO ACUMULADO para equipos internos
        if (ingresoAcum){
          if (tipo === 'EQUIPOS INTERNOS' && total > 0){
            ingresoAcum.textContent = '$' + total.toLocaleString('es-MX', {minimumFractionDigits: 2, maximumFractionDigits: 2});
          } else {
            ingresoAcum.textContent = '';
          }
        }
        
        // RENTA ACUMULADA para equipos externos
        if (rentaAcum){
          if (tipo === 'EQUIPOS EXTERNOS' && total > 0){
            rentaAcum.textContent = '$' + total.toLocaleString('es-MX', {minimumFractionDigits: 2, maximumFractionDigits: 2});
          } else {
            rentaAcum.textContent = '';
          }
        }
      }
      
      if (inicio){
        inicio.addEventListener('change', () => {
          recomputeDias();
          recomputeFinParcialesContinuacion();
        });
        inicio.addEventListener('blur', recomputeFinParcialesContinuacion);
      }
      if (termin){
        termin.addEventListener('change', () => {
          recomputeDias();
          recomputeDevolucion();
          recomputeIngresoRenta();
          recomputeFinParcialesContinuacion();
        });
        termin.addEventListener('blur', recomputeFinParcialesContinuacion);
      }
      if (dias) dias.addEventListener('input', recomputeIngresoRenta);
      if (precio) precio.addEventListener('input', recomputeIngresoRenta);
      sel.addEventListener('change', recomputeIngresoRenta);
      
      // inicializar si ya hubiera presets
      recomputeDias();
      recomputeDevolucion();
      recomputeIngresoRenta();
      recomputeFinParcialesContinuacion();

      // Guardar desde toolbar
      saveRowBtn.onclick = ()=>{
        const baseProp = sel.value==='EQUIPOS INTERNOS' ? 'PCT' : (provInput.value||'');
        const eget = (vars)=> getEditorByVariants(editors, vars);
        // Campos editables
        const valEquipo = eget(['EQUIPO / ACTIVO','EQUIPO/ACTIVO','EQUIPO ACTIVO','EQUIPO'])?.value || '';
        const valCliente = eget(['CLIENTE'])?.value || '';
        const valArea = eget(['AREA DEL CLIENTE','√ÅREA DEL CLIENTE'])?.value || '';
        const valUbic = eget(['UBICACION','UBICACI√ìN'])?.value || '';
        const valFactura = eget(['FACTURA'])?.value || '';
        const valOC = eget(['ORDEN DE COMPRA','ORDEN COMPRA','NO. ORDEN DE COMPRA','NO ORDEN DE COMPRA','N√öMERO DE ORDEN','NUMERO DE ORDEN','OC'])?.value || '';
        const valEmbarque = eget(['FECHA EMBARQUE','FECHA DE EMBARQUE'])?.value || '';
        const valPrecio = eget(['PRECIO'])?.value || '';
        const valEstCot = eget(['EST-COT','COT / ESTIMACION','COT/ESTIMACION','COT ESTIMACION'])?.value || '';
        const valOS = eget(['ORDEN DE SERVICIO','O. S.','O.S.'])?.value || '';
        // Campos auto-generados (texto plano en td, no input)
        const valSerial = eget(['SERIAL','#'])?.textContent || '';
        const valDesc = eget(['DESCRIPCION','DESCRIPCI√ìN'])?.textContent || '';
        // Fechas
        const sInicio = eget(['INICIO DEL SERVICIO'])?.value || '';
        const sTerm = eget(['TERMINACION DEL SERVICIO','TERMINACI√ìN DEL SERVICIO'])?.value || '';
        const dInicio = parseDMY(sInicio);
        const dTerm = parseDMY(sTerm);
        if (!dInicio || !dTerm || dTerm < dInicio){
          alert('Verifica fechas: Inicio y Terminaci√≥n son requeridas y deben estar en orden.');
          return;
        }

        const idx = (variants)=> headerIndex(variants);
        const iPROPIEDAD = idx(['PROPIEDAD']);
        const iSERIAL = idx(['SERIAL','#']);
        const iEQUIPO = idx(['EQUIPO / ACTIVO','EQUIPO/ACTIVO','EQUIPO ACTIVO','EQUIPO']);
        const iDESC = idx(['DESCRIPCION','DESCRIPCI√ìN']);
        const iCLIENTE = idx(['CLIENTE']);
        const iAREA = idx(['AREA DEL CLIENTE','√ÅREA DEL CLIENTE']);
        const iUBIC = idx(['UBICACION','UBICACI√ìN']);
        const iFACT = idx(['FACTURA']);
        const iOC = idx(['ORDEN DE COMPRA','ORDEN COMPRA','NO. ORDEN DE COMPRA','NO ORDEN DE COMPRA','N√öMERO DE ORDEN','NUMERO DE ORDEN','OC']);
        const iESTCOT = idx(['EST-COT','COT / ESTIMACION','COT/ESTIMACION','COT ESTIMACION']);
        const iOS = idx(['ORDEN DE SERVICIO','O. S.','O.S.']);
        const iEMB = idx(['FECHA EMBARQUE','FECHA DE EMBARQUE']);
        const iINI = idx(['INICIO DEL SERVICIO']);
        const iCONT = idx(['CONTINUACION DEL SERVICIO','CONTINUACI√ìN DEL SERVICIO']);
        const iFINP = idx(['FIN PARCIAL DEL SERVICIO']);
        const iTERM = idx(['TERMINACION DEL SERVICIO','TERMINACI√ìN DEL SERVICIO']);
        const iDEV = idx(['FECHA DE DEVOLUCION','FECHA DE DEVOLUCI√ìN']);
        const iDIAS = idx(['DIAS EN SERVICIO','D√çAS EN SERVICIO']);
        const iPREC = idx(['PRECIO']);
        const iINGR = idx(['INGRESO ACUMULADO','INGRESO ACUMULDDO']);
        const iREN  = idx(['RENTA ACUMULADA']);

        function makeRow(){ return new Array(headers.length).fill(''); }
        function fillCommon(r){
          if (iPROPIEDAD>=0) r[iPROPIEDAD] = baseProp;
          if (iSERIAL>=0) r[iSERIAL] = valSerial;
          if (iEQUIPO>=0) r[iEQUIPO] = valEquipo;
          if (iDESC>=0) r[iDESC] = valDesc;
          if (iCLIENTE>=0) r[iCLIENTE] = valCliente;
          if (iAREA>=0) r[iAREA] = valArea;
          if (iUBIC>=0) r[iUBIC] = valUbic;
          if (iFACT>=0) r[iFACT] = valFactura;
          if (iOC>=0) r[iOC] = valOC;
          if (iESTCOT>=0) r[iESTCOT] = valEstCot;
          if (iOS>=0) r[iOS] = valOS;
          if (iEMB>=0) r[iEMB] = valEmbarque;
          if (iPREC>=0) r[iPREC] = valPrecio;
        }

        // Crear solo UNA fila por registro (sin cortes administrativos)
        const r = makeRow();
        fillCommon(r);
        
        // Fechas: inicio y terminaci√≥n completas
        if (iINI>=0) r[iINI] = formatDMY(dInicio);
        if (iTERM>=0) r[iTERM] = formatDMY(dTerm);
        // Fin parcial y Continuaci√≥n
        if (iFINP>=0 || iCONT>=0){
          const fins = [];
          const conts = [];
          // Primera fecha fin parcial = inicio + 25 d√≠as
          let cursor = new Date(dInicio);
          cursor.setDate(cursor.getDate() + 25);
          cursor.setHours(0,0,0,0);
          while (cursor < dTerm){
            fins.push(formatDMY(cursor));
            // Continuaci√≥n = d√≠a siguiente
            const cNext = new Date(cursor);
            cNext.setDate(cNext.getDate() + 1);
            conts.push(formatDMY(cNext));
            // Siguiente fin parcial = actual + 30 d√≠as
            cursor.setDate(cursor.getDate() + 30);
          }
          if (iFINP>=0) r[iFINP] = fins.join('\n');
          if (iCONT>=0) r[iCONT] = conts.join('\n');
        }
        
        // Fecha de devoluci√≥n = terminaci√≥n + 1 d√≠a
        if (iDEV>=0) {
          const dev = new Date(dTerm);
          dev.setDate(dev.getDate() + 1);
          r[iDEV] = formatDMY(dev);
        }
        
        // D√≠as en servicio totales
        const diasTotales = daysInclusive(dInicio, dTerm);
        if (iDIAS>=0) r[iDIAS] = String(diasTotales);
        
        // Calcular ingreso/renta acumulados = dias totales * precio
        const precioNum = parseFloat(String(valPrecio||'').replace(/,/g,''));
        if (!isNaN(diasTotales) && !isNaN(precioNum)){
          const monto = diasTotales * precioNum;
          if (iINGR>=0) r[iINGR] = String(monto);
          if (iREN>=0)  r[iREN]  = String(monto);
        }
        
        const newRows = [r];

        // Insertar nuevas filas al inicio, manteniendo orden cronol√≥gico dentro de lo insertado
        rows = [...newRows, ...rows];
        view = rows;
        tr.remove();
        buildExternalOptionsBase();
        renderHead();
        renderBody(view);
        // Persistir en localStorage y Firestore
        try{
          const keyLS = 'actividad:newRows';
          const prev = JSON.parse(localStorage.getItem(keyLS)||'[]');
          const next = Array.isArray(prev) ? [...newRows, ...prev] : [...newRows];
          localStorage.setItem(keyLS, JSON.stringify(next));
          
          // Guardar en Firestore tambi√©n
          (async () => {
            for (const row of newRows) {
              await saveToFirestore(row);
            }
          })();
        }catch(e){
          console.error('[actividad] Error al persistir:', e);
        }
        // Agregar un registro visual al log inferior
        try{
          const ul = document.getElementById('activity-log-list');
          if (ul){
            const serial = invSerialByEquipo.get(valEquipo) || invSerialByEquipo.get(String(valEquipo||'').toUpperCase()) || '';
            const li = document.createElement('li');
            li.style.padding = '6px 8px';
            li.style.borderTop = '1px solid #e5e7eb';
            const labelCli = valCliente ? ` ¬∑ Cliente: ${valCliente}` : '';
            const labelOC = valOC ? ` ¬∑ OC: ${valOC}` : '';
            const labelFact = valFactura ? ` ¬∑ Factura: ${valFactura}` : '';
            const rango = `${formatDMY(dInicio)} ‚Äì ${formatDMY(dTerm)}`;
            li.textContent = `${valEquipo}${serial?` (SERIAL: ${serial})`:''} ¬∑ ${rango}${labelCli}${labelOC}${labelFact}`;
            ul.insertBefore(li, ul.firstChild);
          }
        }catch{}
        // limpiar estado toolbar
        currentNewRowEl = null; currentEditors = null; currentSelTipo = null; currentProvInput = null;
        setToolbarEditing(false);
      };

      // Cancelar desde toolbar
      cancelRowBtn.onclick = ()=>{
        tr.remove(); updateActivityKpis();
        currentNewRowEl = null; currentEditors = null; currentSelTipo = null; currentProvInput = null;
        setToolbarEditing(false);
      };
    }

    newRowBtn.addEventListener('click', insertNewEditableRow);

    q.addEventListener('input', applyFilter);
    clearQ.addEventListener('click', ()=>{ q.value=''; applyFilter(); q.focus(); });
    
    // Usar window.load en lugar de DOMContentLoaded para asegurar que CSS est√© completamente aplicado
    if (document.readyState === 'complete') {
      // Si ya est√° cargado (ej. navegaci√≥n back), ejecutar inmediatamente
      setTimeout(load, 0);
    } else {
      window.addEventListener('load', load);
    }
  })();
  </script>
</body>
</html>